<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ghép Ảnh Tabor 1 - Giáo Phận Vĩnh Long</title>
<style>
  html,body{height:100%;margin:0}
  body{
    background: url('bg.jpg') center/cover fixed no-repeat;
    display:flex;align-items:center;justify-content:center;
    font-family:system-ui, Arial;
    overflow:hidden;
  }
  canvas{display:block; background:transparent; touch-action:none; max-width:90vw; max-height:90vh;}
  #controls{position:fixed;bottom:12px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.45);padding:8px;border-radius:8px;display:flex;gap:8px;align-items:center}
  #controls button,input[type=range]{padding:8px 10px;border-radius:6px;border:0;color:#fff;background:#ff6b6b;cursor:pointer}
  #controls input[type=file]{display:none}
  #zoomLabel{color:#fff;margin-left:6px}
</style>
</head>
<body>

<canvas id="canvas" aria-label="Preview"></canvas>

<div id="controls">
  <label style="background:#fff;color:#000;padding:6px 8px;border-radius:6px;cursor:pointer">
    Import
    <input id="upload" type="file" accept="image/*">
  </label>

  <div style="display:flex;align-items:center;color:#fff">
    <input id="zoom" type="range" min="1" max="3" step="0.01" value="1">
    <span id="zoomLabel">1.00×</span>
  </div>

  <button id="download">Tải ảnh</button>
</div>

<script>
/* ==== CẤU HÌNH (không cần chỉnh nếu dùng frame.png gốc) ==== */
const FRAME_W = 2048, FRAME_H = 2048;
// Vùng ô đen trong frame (từ file frame.png đã đo)
const MASK = { x:475, y:164, w:1113, h:1529 };

/* ==== DOM ==== */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const upload = document.getElementById('upload');
const zoomInput = document.getElementById('zoom');
const zoomLabel = document.getElementById('zoomLabel');
const downloadBtn = document.getElementById('download');

let frameImg = new Image();
frameImg.src = 'frame.png';

/* trạng thái trong hệ toạ độ frame (2048x2048) */
let dispScale = 1;           // tỉ lệ canvas->frame (canvas.width = FRAME_W * dispScale)
let baseImg = null;         // ảnh đã resize fill mask (Image)
let currScale = 1;          // scale applied to baseImg (1 = kích thước đã resize)
let offsetX = 0, offsetY = 0; // vị trí baseImg trong toạ độ frame
let dragging = false;
let lastClientX = 0, lastClientY = 0;

/* ==== resize canvas cho vừa cửa sổ ==== */
function resizeCanvas(){
  const maxW = window.innerWidth * 0.9;
  const maxH = window.innerHeight * 0.9;
  dispScale = Math.min(maxW / FRAME_W, maxH / FRAME_H);
  canvas.width = Math.round(FRAME_W * dispScale);
  canvas.height = Math.round(FRAME_H * dispScale);
  draw();
}
window.addEventListener('resize', resizeCanvas);

/* khi frame load xong -> set canvas lần đầu */
frameImg.onload = () => { resizeCanvas(); };

/* ==== helper clamp: giữ ảnh luôn phủ kín MASK ==== */
function clampPosition() {
  if(!baseImg) return;
  const drawW = baseImg.width * currScale;
  const drawH = baseImg.height * currScale;

  // Nếu ảnh nhỏ hơn mask (không xảy ra vì baseImg đã resize để >= mask),
  // ta center nó; else giới hạn offset để thỏa mãn covering.
  if(drawW <= MASK.w) {
    offsetX = MASK.x + (MASK.w - drawW)/2;
  } else {
    const minX = MASK.x + MASK.w - drawW; // nhỏ nhất
    const maxX = MASK.x;
    if(offsetX < minX) offsetX = minX;
    if(offsetX > maxX) offsetX = maxX;
  }

  if(drawH <= MASK.h) {
    offsetY = MASK.y + (MASK.h - drawH)/2;
  } else {
    const minY = MASK.y + MASK.h - drawH;
    const maxY = MASK.y;
    if(offsetY < minY) offsetY = minY;
    if(offsetY > maxY) offsetY = maxY;
  }
}

/* ==== vẽ lên canvas (mọi coords là hệ FRAME -> scale sang canvas khi draw) ==== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // vẽ nền (transparent) -> để nhìn thấy bg.jpg body
  // vẽ ảnh user (bên dưới frame) nhưng chỉ trong vùng MASK (clip)
  if(baseImg) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(MASK.x * dispScale, MASK.y * dispScale, MASK.w * dispScale, MASK.h * dispScale);
    ctx.clip();
    ctx.drawImage(
      baseImg,
      offsetX * dispScale,
      offsetY * dispScale,
      baseImg.width * currScale * dispScale,
      baseImg.height * currScale * dispScale
    );
    ctx.restore();
  }

  // vẽ frame lên trên (scale theo dispScale)
  ctx.drawImage(frameImg, 0, 0, FRAME_W * dispScale, FRAME_H * dispScale);
}

/* ==== upload: resize upfront để baseImg >= mask ==== */
upload.addEventListener('change', e=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = ev=>{
    const tmp = new Image();
    tmp.onload = ()=>{
      // resize để cover mask: ratio = max(maskW/tmp.w, maskH/tmp.h)
      const ratio = Math.max(MASK.w / tmp.width, MASK.h / tmp.height);
      const newW = Math.round(tmp.width * ratio);
      const newH = Math.round(tmp.height * ratio);
      const off = document.createElement('canvas');
      off.width = newW; off.height = newH;
      off.getContext('2d').drawImage(tmp,0,0,newW,newH);
      const dataUrl = off.toDataURL('image/png');

      // baseImg là ảnh đã resize (trong hệ frame pixels)
      const b = new Image();
      b.onload = ()=>{
        baseImg = b;
        // đặt scale mặc định = 1 (1 = kích thước đã resize)
        currScale = 1;
        // offset sao cho ảnh được center trong mask
        offsetX = MASK.x + (MASK.w - baseImg.width)/2;
        offsetY = MASK.y + (MASK.h - baseImg.height)/2;
        // set zoom slider min = 1 để không cho bé hơn (không lộ nền)
        zoomInput.min = 1;
        zoomInput.value = 1;
        zoomLabel.textContent = "1.00×";
        clampPosition();
        draw();
      };
      b.src = dataUrl;
    };
    tmp.src = ev.target.result;
  };
  reader.readAsDataURL(f);
});

/* ==== zoom control ==== */
zoomInput.addEventListener('input', e=>{
  const prevScale = currScale;
  currScale = parseFloat(e.target.value);
  // giữ điểm giữa mask khi zoom (giữ center of mask ổn định)
  const cx = MASK.x + MASK.w/2;
  const cy = MASK.y + MASK.h/2;
  // point in image coords under mask center before scale:
  const imgPointX = (cx - offsetX) / prevScale;
  const imgPointY = (cy - offsetY) / prevScale;
  // adjust offset so mask center vẫn trỏ vào same image point
  offsetX = cx - imgPointX * currScale;
  offsetY = cy - imgPointY * currScale;

  clampPosition();
  zoomLabel.textContent = currScale.toFixed(2) + "×";
  draw();
});

/* ==== drag (mouse + touch) ==== */
canvas.addEventListener('mousedown', e=>{
  if(!baseImg) return;
  dragging = true;
  lastClientX = e.clientX;
  lastClientY = e.clientY;
});
window.addEventListener('mousemove', e=>{
  if(!dragging || !baseImg) return;
  const dx = (e.clientX - lastClientX) / dispScale; // convert canvas px -> frame px
  const dy = (e.clientY - lastClientY) / dispScale;
  offsetX += dx;
  offsetY += dy;
  lastClientX = e.clientX; lastClientY = e.clientY;
  clampPosition();
  draw();
});
window.addEventListener('mouseup', ()=>{ dragging = false; });

/* touch drag */
canvas.addEventListener('touchstart', e=>{
  if(!baseImg) return;
  if(e.touches.length === 1){
    dragging = true;
    lastClientX = e.touches[0].clientX;
    lastClientY = e.touches[0].clientY;
  }
}, {passive:false});
canvas.addEventListener('touchmove', e=>{
  if(!dragging || !baseImg) return;
  if(e.touches.length === 1){
    const dx = (e.touches[0].clientX - lastClientX) / dispScale;
    const dy = (e.touches[0].clientY - lastClientY) / dispScale;
    offsetX += dx; offsetY += dy;
    lastClientX = e.touches[0].clientX; lastClientY = e.touches[0].clientY;
    clampPosition();
    draw();
  }
  e.preventDefault();
}, {passive:false});
canvas.addEventListener('touchend', ()=>{ dragging = false; });

/* ==== download full-res 2048x2048 ==== */
downloadBtn.addEventListener('click', ()=>{
  // create export canvas at frame original size
  const out = document.createElement('canvas');
  out.width = FRAME_W; out.height = FRAME_H;
  const octx = out.getContext('2d');

  // (optional) fill background transparent or color
  octx.clearRect(0,0,out.width,out.height);

  if(baseImg){
    octx.save();
    octx.beginPath();
    octx.rect(MASK.x, MASK.y, MASK.w, MASK.h);
    octx.clip();
    octx.drawImage(baseImg, offsetX, offsetY, baseImg.width * currScale, baseImg.height * currScale);
    octx.restore();
  }

  // draw frame at full resolution
  const f = new Image();
  f.onload = ()=>{
    octx.drawImage(f,0,0,FRAME_W,FRAME_H);
    const link = document.createElement('a');
    link.download = 'result.png';
    link.href = out.toDataURL('image/png');
    link.click();
  };
  f.src = 'frame.png';
});

/* ==== start ==== */
resizeCanvas();
</script>
</body>
</html>
